/* Mesquite source code.  Copyright 1997 and onward, W. Maddison and D. Maddison. 


 Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. 
 The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.
 Perhaps with your help we can be more than a few, and make Mesquite better.

 Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.
 Mesquite's web site is http://mesquiteproject.org

 This source code and its compiled class files are free and modifiable under the terms of 
 GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)
 */
package mesquite.zephyr.TreeInferenceCoordinator;
/*~~  */

import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Vector;

import mesquite.lib.CommandChecker;
import mesquite.lib.MesquiteCommand;
import mesquite.lib.MesquiteFile;
import mesquite.lib.MesquiteInteger;
import mesquite.lib.MesquiteLong;
import mesquite.lib.MesquiteModule;
import mesquite.lib.MesquiteTrunk;
import mesquite.lib.Notification;
import mesquite.lib.ParseUtil;
import mesquite.lib.Parser;
import mesquite.lib.Snapshot;
import mesquite.lib.StringUtil;
import mesquite.lib.duties.FileInit;
import mesquite.lib.duties.TreeInferer;
import mesquite.lib.ui.AlertDialog;
import mesquite.lib.ui.MesquiteHTMLWindow;
import mesquite.zephyr.lib.TreeInferenceHandler;

/* ======================================================================== */
/* this hires handlers, which run the tree inferences.  It is a central manager, not detail-oriented.*/
public class TreeInferenceCoordinator extends FileInit implements MouseListener {
	Vector handlers;  //(these are TreeInferenceHandler)
	MesquiteHTMLWindow window = null;
	MesquiteCommand linkTouchedCommand;
	/*.................................................................................................................*/
	public boolean startJob(String arguments, Object condition, boolean hiredByName) {
		if (numModulesAvailable(TreeInferer.class)>0){  //ExternalTreeSearcher
			getFileCoordinator().addSubmenu(MesquiteTrunk.analysisMenu, "Tree Inference", makeCommand("inferTrees",  this), TreeInferer.class);
			handlers = new Vector();
			linkTouchedCommand = new MesquiteCommand("linkTouched", this);
			makeMenu("Inference");
			addMenuItem("No Inferences", null);  //just in case...? This is deleted as soon as redoMenu is called
			return true;
		}
		return false;
	}
	public Class getHireSubchoice(){  //somewhat nonstandard; this is not to hire a direct employee of this module, but rather to make the submenu and receive the indication as to what inferer the handler is supposed to hire
		return TreeInferer.class;
	}
	/*.................................................................................................................*/
	/** Generated by an employee who quit.  The MesquiteModule should act accordingly. */
	public void employeeQuit(MesquiteModule employee) {
		handlers.removeElement(employee);
		redoMenu();
		resetWindow();
	}

	void redoMenu() {
		deleteAllMenuItems();
		if (handlers.size()>1) {
			addMenuItem("Stop All Inferences", makeCommand("stopAll", this));
			addMenuItem("-", null);
		}
		for (int i = 0; i<handlers.size(); i++) {
			TreeInferenceHandler e=(TreeInferenceHandler)handlers.elementAt(i);
			addMenuItem("Stop Inference #" + (i+1) +" (" + e.getInferenceName() + ")", new MesquiteCommand("stopInference", MesquiteLong.toString(e.getID()), this));
		}
		resetContainingMenuBar();
	}
	//DW: get rid of progress indicators now that window is available???  They are very annoying
	//DW: if any inference going then add menu item to kill all inferences
	//DW: where to put autosave? -- best to put burden of choice on inferer's interface, and add method so handler can query inferer as to whether autosave is in effect
	//DW: currently ALWAYS on separate thread; therefore LOCK taxa block to editing?
	//DW: add window snapshot
	//DW: move to Analysis menu?
	/*.................................................................................................................*/
	TreeInferenceHandler findHandlerByID(int id){
		for (int i = 0; i<handlers.size(); i++) {
			TreeInferenceHandler e=(TreeInferenceHandler)handlers.elementAt(i);
			if(e.getID() == id)
				return e;
		}
		return null;
	}
	/*.................................................................................................................*/
	String getExtraLinks(TreeInferenceHandler e) {
		if (StringUtil.blank(e.getCommandOfTextCommandLink()) || StringUtil.blank(e.getTitleOfTextCommandLink()))
			return "";
		String extraLinks = "(<a href = \"extra-" + e.getCommandOfTextCommandLink() + "-"+e.getID() + "\">" +e.getTitleOfTextCommandLink() + "</a>) ";
		return extraLinks;
	}
	/*.................................................................................................................*/
	String getNameForStopLink(TreeInferenceHandler e) {
		return "Stop";
	}
	/*.................................................................................................................*/
	int whichInferenceInLog = 0;
	String getStatusHTML(int numLinesPerHandler){
		String body="";
		if (whichInferenceInLog >= handlers.size())
			whichInferenceInLog = 0;
		if (handlers.size() == 0)
			body+= "No inferences running";
		else {
			body += "<h2>Inferences in progress</h2><hr size=\"3\" noshade=\"noshade\" />";
			StringBuffer extraPanelText = new StringBuffer();
			String logTest = "";
			for (int i = 0; i<handlers.size(); i++) {
				TreeInferenceHandler e=(TreeInferenceHandler)handlers.elementAt(i);
				body +=  " (<a href = \"kill-" + e.getID() + "\">"+getNameForStopLink(e)+"</a>) " + getExtraLinks(e)+ e.getHTMLDescriptionOfStatus(numLinesPerHandler) 
				+"<p><hr size=\"3\" noshade=\"noshade\" />";
				if (i==whichInferenceInLog) {
					extraPanelText.append("Log from " + e.getInferenceName() + "\n===================\n"); 
					String lt = e.getLogText();
					if (StringUtil.blank(lt))
						lt = "";
					else
						lt += ("\n===================\nLog from " + e.getInferenceName()); 

					extraPanelText.append(lt);
					e.setOutputTextListener(window);
				}
			}
			window.setExtraPanelText(extraPanelText.toString());

		}
		if (StringUtil.notEmpty(body))
			return  "<html><body>"+ body+"</body></html>";
		return "";
	}
	//handler of clicks in extra panel for log
	public void mouseClicked(MouseEvent arg0) {
		whichInferenceInLog++;
		if (whichInferenceInLog >= handlers.size())
			whichInferenceInLog = 0;
		TreeInferenceHandler e=(TreeInferenceHandler)handlers.elementAt(whichInferenceInLog);
		String lt = e.getLogText();
		if (StringUtil.blank(lt))
			lt = "";
		else
			lt += ("\n===================\nLog from " + e.getInferenceName()); 
		window.setExtraPanelText("Log from " + e.getInferenceName() + "\n===================\n"+lt);
		e.setOutputTextListener(window);
	}
	public void mouseEntered(MouseEvent e) {
	}
	public void mouseExited(MouseEvent e) {
	}
	public void mousePressed(MouseEvent e) {
	}
	public void mouseReleased(MouseEvent e) {
	}
	/*.................................................................................................................*
	String getStdOutText(){
		String body="blah blah blah";
		 return body;
	}
	/*.................................................................................................................*/
	void initiateWindow(){
		if (window == null) {
			window = new MesquiteHTMLWindow(this, linkTouchedCommand, "Tree Inference in Progress", true, false, true);
			window.setBackEnabled(false);
			window.setExtraPanelListener(this);
		}
		window.setShowExtraPanel(true);
		window.setText(getStatusHTML(getNumLinesPerHandler()));
		window.setPopAsTile(true);
		window.popOut(true);
		lastWindowStatePopped = true;
		window.setVisible(true);
		window.show();
		window.setExtraPanelText("");
		resetAllMenuBars();

	}
	/*.................................................................................................................*
	public void setLogPanelText(String s) {
		if (window!=null)
			window.setExtraPanelText(s);
	}
	 */
	int getNumLinesPerHandler(){
		if (window == null)
			return 0;

		int numLines = (window.getAvailableHeight()-30 - handlers.size()*50)/16;
		if (handlers.size()== 0)
			return numLines;
		return numLines/handlers.size();
		//rough guess: 100 pixels for extras, then 16 pixels per line
	}
	boolean lastWindowStatePopped = true;
	int resetCount = 0;
	/*.................................................................................................................*/
	void resetWindow(){
		if (window != null) {
			if (handlers.size()> 0){
				if (!window.isVisible()){
					window.setVisible(true);
				}

				if (lastWindowStatePopped && !window.isPoppedOut()){
					window.setPopAsTile(true);
					window.popOut(true);
				}

				window.setText(getStatusHTML(getNumLinesPerHandler()));
			}
			else {
				lastWindowStatePopped = window.isPoppedOut();
				//window.setText(getStatusHTML(getNumLinesPerHandler()));
				window.setVisible(false); 
			}

		}
	}
	/*.................................................................................................................*/
	public void employeeParametersChanged(MesquiteModule employee, MesquiteModule source, Notification notification) {
		resetWindow();
	}
	/*.................................................................................................................*/
	public Snapshot getSnapshot(MesquiteFile file) { 
		Snapshot temp = new Snapshot();
		
		boolean anyToReconnect = false;
		if (file == null || file == getProject().getHomeFile()){

			for (int i = 0; i<handlers.size(); i++) {
				TreeInferenceHandler e=(TreeInferenceHandler)handlers.elementAt(i);
				if (e.isReconnectable()){
					if (!anyToReconnect){ // first one, initiate window
						Snapshot fromWindow = window.getSnapshot(file);
						temp.addLine("initiateWindow");
						temp.addLine("tell It");
						temp.incorporate(fromWindow, true);
						temp.addLine("endTell"); 
					}
					temp.addLine("restoreInference ", e); 
					anyToReconnect = true;
				}
				else
					temp.suppressCommandsToEmployee(e); 
			}
		}
		if (anyToReconnect && handlers.size() >0)
			temp.addLine("resetWindow");
		return temp;
	}

	/*.................................................................................................................*/
	public Object doCommand(String commandName, String arguments, CommandChecker checker) {
		if (checker.compare(this.getClass(), "Hires a tree inferer and infers trees", null, commandName, "inferTrees")) {
			initiateWindow();
			TreeInferenceHandler handler = (TreeInferenceHandler)hireEmployee(TreeInferenceHandler.class, "Tree inference handler");
			if (handler !=null){
				handlers.addElement(handler);
				handler.doCommand("startInference", arguments);  //inferer name passed along to handler
				resetWindow();
				redoMenu();
				return handler;
			}
		}
		else if (checker.compare(this.getClass(), "Initiates the window for a reconnection ", null, commandName, "initiateWindow")) {
			initiateWindow();
			return window;
		}
		else if (checker.compare(this.getClass(), "Reconnects to a tree inferer ", null, commandName, "restoreInference")) {
			initiateWindow();
			TreeInferenceHandler handler = (TreeInferenceHandler)hireNamedEmployee(TreeInferenceHandler.class, arguments);
			if (handler !=null){
				handlers.addElement(handler);
				resetWindow();
				redoMenu();
				return handler;
			}
		}
		else if (checker.compare(this.getClass(), "Does nothing; simply consumes liaison's auto snapshot ", null, commandName, "ignoreInference")) {
		}
		else if (checker.compare(this.getClass(), "resets the window", null, commandName, "resetWindow")) {
			resetWindow();

		}
		else if (checker.compare(this.getClass(), "Stop inference", "[id of handler]", commandName, "stopAll")) {
			for (int i = handlers.size()-1; i>=0; i--) {
				TreeInferenceHandler e=(TreeInferenceHandler)handlers.elementAt(i);
				killInference(e, true);
			}
			return null;
		}
		else if (checker.compare(this.getClass(), "Stop inference", "[id of handler]", commandName, "stopInference")) {
			String token = parser.getFirstToken(arguments);
			int id = MesquiteInteger.fromString(token);
			TreeInferenceHandler handler = findHandlerByID(id);
			if (handler != null) {
				killInference(handler, false);
				return null;
			}

		}
		else if (checker.compare(this.getClass(), "link touched", null, commandName, "linkTouched")) {
			String token = parser.getFirstToken(arguments);
			if (token != null && token.startsWith("kill")){
				String idS = token.substring(5, token.length());
				int id = MesquiteInteger.fromString(idS);
				TreeInferenceHandler handler = findHandlerByID(id);
				if (handler != null) {
					killInference(handler, false);
					return null;
				}
			} else if (token != null && token.startsWith("extra")){
				Parser parser = new Parser();
				parser.setWhitespaceString("-");
				String idS = token.substring(6, token.length());
				parser.setString(idS);
				String command = parser.getFirstToken();
				String idString = parser.getNextToken();
				int id = MesquiteInteger.fromString(idString);
				TreeInferenceHandler handler = findHandlerByID(id);
				if (handler != null) {
					handler.processUserClickingOnTextCommandLink(command);
					return null;
				}
			}

		}
		else
			return  super.doCommand(commandName, arguments, checker);
		return null;
	}

	void killInference(TreeInferenceHandler handler, boolean queryWithName) {
		int response = 1;
		logln("User request to stop tree inference");
		String message = handler.getMessageIfUserAbortRequested();
		String inferenceName = "";
		if (queryWithName)
			inferenceName = " " + handler.getInferenceName();
		if (handler.canStoreLatestTree()){
			response = AlertDialog.queryLongMessage(containerOfModule(), "Stop analysis" + inferenceName + "? Save tree?", "Stop analysis" + inferenceName + "? Save the current tree in the inference?", message, "Stop & Save Tree", "Stop & Don't Save Tree", "Cancel", 2, "");
			if (response==0)
				handler.storeLatestTreeAfterAbort();
			if (response<2) {
				handler.setUserAborted();
				handler.stopInference(true, response == 0);
			}
		}
		else	if (handler.canStoreMultipleCurrentTrees()){
			response = AlertDialog.queryLongMessage(containerOfModule(), "Stop analysis" + inferenceName + "? Save trees?", "Stop analysis" + inferenceName + "? Save current trees in the inference?", message, "Stop & Save Trees", "Stop & Don't Save Trees", "Cancel", 2, "");
			if (response==0)
				handler.storeMultipleCurrentTreesAfterAbort();
			if (response<2) {
				handler.setUserAborted();
				handler.stopInference(true, response == 0);
			}
		} else if (AlertDialog.query(this, "Stop analysis" + inferenceName + "?", "Do you want to stop the analysis" + inferenceName + "? Preliminary trees will not be saved.\n"+message, "Stop", "Cancel")) {
			handler.setUserAborted();
			handler.stopInference(true, false);
		}
	}
	/*.................................................................................................................*/
	public void endJob() {
		if (handlers!=null)
			for (int i = 0; i<handlers.size(); i++) {
				TreeInferenceHandler handler=(TreeInferenceHandler)handlers.elementAt(i);
				if (handler!=null){
					handler.stopInference(false, false);
				}
			}
		super.endJob();
	}
	/*.................................................................................................................*/
	public boolean isPrerelease() { 
		return false;
	}
	/*.................................................................................................................*/
	public String getNameForMenuItem() {
		return "Tree Inference";
	}
	/*.................................................................................................................*/
	public String getName() {
		return "Tree Inference Coordinator";
	}
	/*.................................................................................................................*/
	/** returns the version number at which this module was first released.  If 0, then no version number is claimed.  If a POSITIVE integer
	 * then the number refers to the Mesquite version.  This should be used only by modules part of the core release of Mesquite.
	 * If a NEGATIVE integer, then the number refers to the local version of the package, e.g. a third party package*/
	public int getVersionOfFirstRelease(){
		return -2000;  
	}
	/*.................................................................................................................*/
	/** returns an explanation of what the module does.*/
	public String getExplanation() {
		return "Coordinates tree inferers." ;  
	}


}


